/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, NodCollectionExtension, ExecuteMsg, Timestamp, Uint64, Decimal, Uint128, Denom, Addr, Currency, State, SubmitExtension, NodEntity, QueryMsg, Order, MigrateMsg, TokensResponse, ContractInfoResponseForNodConfig, NodConfig, CollectionInfo, Expiration, OwnershipForString, NftInfoResponseForNodData, NodData, NumTokensResponse, OwnerOfResponse } from "./Nod.types";
export interface NodReadOnlyInterface {
  contractAddress: string;
  contractInfo: () => Promise<ContractInfoResponseForNodConfig>;
  ownerOf: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<OwnerOfResponse>;
  numTokens: () => Promise<NumTokensResponse>;
  getMinterOwnership: () => Promise<OwnershipForString>;
  getCreatorOwnership: () => Promise<OwnershipForString>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<NftInfoResponseForNodData>;
  tokens: ({
    limit,
    owner,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    owner: string;
    queryOrder?: Order;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    queryOrder?: Order;
    startAfter?: string;
  }) => Promise<TokensResponse>;
}
export class NodQueryClient implements NodReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.contractInfo = this.contractInfo.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.getMinterOwnership = this.getMinterOwnership.bind(this);
    this.getCreatorOwnership = this.getCreatorOwnership.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
  }
  contractInfo = async (): Promise<ContractInfoResponseForNodConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  ownerOf = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        token_id: tokenId
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  getMinterOwnership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_minter_ownership: {}
    });
  };
  getCreatorOwnership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_creator_ownership: {}
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<NftInfoResponseForNodData> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    owner: string;
    queryOrder?: Order;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        query_order: queryOrder,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    queryOrder?: Order;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        query_order: queryOrder,
        start_after: startAfter
      }
    });
  };
}
export interface NodInterface extends NodReadOnlyInterface {
  contractAddress: string;
  sender: string;
  submit: ({
    extension,
    owner,
    tokenId
  }: {
    extension: SubmitExtension;
    owner: string;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    tokenId
  }: {
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  burnAll: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class NodClient extends NodQueryClient implements NodInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.submit = this.submit.bind(this);
    this.burn = this.burn.bind(this);
    this.burnAll = this.burnAll.bind(this);
  }
  submit = async ({
    extension,
    owner,
    tokenId
  }: {
    extension: SubmitExtension;
    owner: string;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit: {
        extension,
        owner,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  burn = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  burnAll = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn_all: {}
    }, fee_, memo_, funds_);
  };
}
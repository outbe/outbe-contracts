/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Denom, Addr, Currency, Decimal, InstantiateMsg, TributeCollectionExtension, ExecuteMsg, Action, Expiration, Timestamp, Uint64, Uint128, CollectionInfoMsgForNullable_TributeCollectionExtension, MintExtension, TributeMintData, QueryMsg, Order, MigrateMsg, TokensResponse, ContractInfoResponseForTributeConfig, TributeConfig, CollectionInfo, DailyTributesResponse, FullTributeData, TributeData, OwnershipForString, NftInfoResponseForTributeData, NumTokensResponse, OwnerOfResponse } from "./Tribute.types";
export interface TributeReadOnlyInterface {
  contractAddress: string;
  contractInfo: () => Promise<ContractInfoResponseForTributeConfig>;
  ownerOf: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<OwnerOfResponse>;
  numTokens: () => Promise<NumTokensResponse>;
  getMinterOwnership: () => Promise<OwnershipForString>;
  getCreatorOwnership: () => Promise<OwnershipForString>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<NftInfoResponseForTributeData>;
  tokens: ({
    limit,
    owner,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    owner: string;
    queryOrder?: Order;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    queryOrder?: Order;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  dailyTributes: ({
    date
  }: {
    date: number;
  }) => Promise<DailyTributesResponse>;
}
export class TributeQueryClient implements TributeReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.contractInfo = this.contractInfo.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.getMinterOwnership = this.getMinterOwnership.bind(this);
    this.getCreatorOwnership = this.getCreatorOwnership.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
    this.dailyTributes = this.dailyTributes.bind(this);
  }
  contractInfo = async (): Promise<ContractInfoResponseForTributeConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  ownerOf = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        token_id: tokenId
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  getMinterOwnership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_minter_ownership: {}
    });
  };
  getCreatorOwnership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_creator_ownership: {}
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<NftInfoResponseForTributeData> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    owner: string;
    queryOrder?: Order;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        query_order: queryOrder,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    queryOrder,
    startAfter
  }: {
    limit?: number;
    queryOrder?: Order;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        query_order: queryOrder,
        start_after: startAfter
      }
    });
  };
  dailyTributes = async ({
    date
  }: {
    date: number;
  }): Promise<DailyTributesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      daily_tributes: {
        date
      }
    });
  };
}
export interface TributeInterface extends TributeReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateMinterOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateCreatorOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateBurnerOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateCollectionInfo: ({
    collectionInfo
  }: {
    collectionInfo: CollectionInfoMsgForNullable_TributeCollectionExtension;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  mint: ({
    extension,
    owner,
    tokenId,
    tokenUri
  }: {
    extension: MintExtension;
    owner: string;
    tokenId: string;
    tokenUri?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    tokenId
  }: {
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  burnAll: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class TributeClient extends TributeQueryClient implements TributeInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateMinterOwnership = this.updateMinterOwnership.bind(this);
    this.updateCreatorOwnership = this.updateCreatorOwnership.bind(this);
    this.updateBurnerOwnership = this.updateBurnerOwnership.bind(this);
    this.updateCollectionInfo = this.updateCollectionInfo.bind(this);
    this.mint = this.mint.bind(this);
    this.burn = this.burn.bind(this);
    this.burnAll = this.burnAll.bind(this);
  }
  updateMinterOwnership = async (action: Action, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_minter_ownership: action
    }, fee_, memo_, funds_);
  };
  updateCreatorOwnership = async (action: Action, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_creator_ownership: action
    }, fee_, memo_, funds_);
  };
  updateBurnerOwnership = async (action: Action, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_burner_ownership: action
    }, fee_, memo_, funds_);
  };
  updateCollectionInfo = async ({
    collectionInfo
  }: {
    collectionInfo: CollectionInfoMsgForNullable_TributeCollectionExtension;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_collection_info: {
        collection_info: collectionInfo
      }
    }, fee_, memo_, funds_);
  };
  mint = async ({
    extension,
    owner,
    tokenId,
    tokenUri
  }: {
    extension: MintExtension;
    owner: string;
    tokenId: string;
    tokenUri?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint: {
        extension,
        owner,
        token_id: tokenId,
        token_uri: tokenUri
      }
    }, fee_, memo_, funds_);
  };
  burn = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  burnAll = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn_all: {}
    }, fee_, memo_, funds_);
  };
}